(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(*                              Hongwei Xi                             *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Anairiats - Unleashing the Potential of Types!
** Copyright (C) 2002-2008 Hongwei Xi, Boston University
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (hwxi AT cs DOT bu DOT edu)
// Start Time: April 2008
//
(* ****** ****** *)

%{^
#include "libc/CATS/time.cats" // only needed for ATS/Geizella
%} // end of [%{^]

(* ****** ****** *)

staload TM = "libc_sats_time.sats"

(* ****** ****** *)

staload Deb = "ats_debug.sats"
staload Err = "ats_error.sats"
staload Fil = "ats_filename.sats"
typedef fil_t = $Fil.filename_t
staload Glo = "ats_global.sats"
staload Lst = "ats_list.sats"
staload Sym = "ats_symbol.sats"
staload Syn = "ats_syntax.sats"

(* ****** ****** *)

staload "ats_staexp2.sats"
staload "ats_dynexp2.sats"

(* ****** ****** *)

staload SDC = "ats_stadyncst2.sats"
staload TR2Env = "ats_trans2_env.sats"

(* ****** ****** *)

staload "ats_hiexp.sats"
staload "ats_trans4.sats"
staload "ats_ccomp.sats"
staload "ats_ccomp_env.sats"

(* ****** ****** *)

stadef fmlte = file_mode_lte

(* ****** ****** *)

fun prerr_interror () =
  prerr "INTERNAL ERROR (ats_ccomp_main)"

(* ****** ****** *)

fn emit_time_stamp {m:file_mode}
  (pf: fmlte (m, w) | out: &FILE m): void = let
  var time: $TM.time_t = $TM.time_get ()
  val (pfopt | p_tm) = $TM.localtime (time)
in
//
if p_tm > null then let
  prval Some_v @(pf1, fpf1) = pfopt
  val tm_min = $TM.tm_get_min (!p_tm)
  val tm_hour = $TM.tm_get_hour (!p_tm)
  val tm_mday = $TM.tm_get_mday (!p_tm)
  val tm_mon = 1 + $TM.tm_get_mon (!p_tm)
  val tm_year = 1900 + $TM.tm_get_year (!p_tm)
  prval () = fpf1 (pf1)
in
  fprint1_string (pf | out, "/*\n");
  fprint1_string (pf | out, "**\n");
  fprint1_string (pf | out,
    "** The C code is generated by ATS/Anairiats\n"
  );
  fprint1_string (pf | out, "** The compilation time is: ");
  fprintf1_exn (pf | out
  , "%i-%i-%i: %2ih:%2im\n"
  , @(tm_year, tm_mon, tm_mday, tm_hour, tm_min)
  );
  fprint1_string (pf | out, "**\n");
  fprint1_string (pf | out, "*/\n\n");
end else let
  prval None_v () = pfopt
in
  // nothing
end (* end of [if] *)
//
end // end of [emit_time_stamp]

(* ****** ****** *)

fn emit_include_header {m:file_mode}
  (pf: fmlte (m, w) | out: &FILE m): void = let
  val () = fprint1_string (pf | out, "/* include some .h files */\n")
  val () = fprint1_string (pf | out, "#ifndef _ATS_HEADER_NONE\n")
  val () = fprint1_string (pf | out, "#include \"ats_config.h\"\n")
  val () = fprint1_string (pf | out, "#include \"ats_basics.h\"\n")
  val () = fprint1_string (pf | out, "#include \"ats_types.h\"\n")
  val () = fprint1_string (pf | out, "#include \"ats_exception.h\"\n")
  val () = fprint1_string (pf | out, "#include \"ats_memory.h\"\n")
  val () = fprint1_string (pf | out, "#endif /* _ATS_HEADER_NONE */\n")
  val () = fprint1_char (pf | out, '\n')
in
  // empty
end // end of [emit_include_header]

(* ****** ****** *)

fn emit_include_cats {m:file_mode}
  (pf: fmlte (m, w) | out: &FILE m): void = let
//
// HX: primary data structure
//
  val () = fprint1_string (pf | out, "/* include some .cats files */\n")
  val () = fprint1_string (pf | out, "#ifndef _ATS_PRELUDE_NONE\n")
//
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/basics.cats\"\n")
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/integer.cats\"\n")
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/sizetype.cats\"\n")
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/integer_ptr.cats\"\n")
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/integer_fixed.cats\"\n")
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/pointer.cats\"\n")
//
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/bool.cats\"\n")
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/char.cats\"\n")
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/byte.cats\"\n")
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/float.cats\"\n")
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/string.cats\"\n")
//
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/reference.cats\"\n")
//
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/lazy.cats\"\n")
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/lazy_vt.cats\"\n")
//
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/printf.cats\"\n")
//
// HX: secondary data structures
//
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/list.cats\"\n")
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/option.cats\"\n")
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/array.cats\"\n")
  val () = fprint1_string (pf | out, "#include \"prelude/CATS/matrix.cats\"\n")
  val () = fprint1_string (pf | out, "#endif /* _ATS_PRELUDE_NONE */\n")
in
  // empty
end // end of [emit_include_cats]

(* ****** ****** *)

fn atarray_name_test
  (name: string): bool = let
  val name = string1_of_string name
  val isend = string_is_atend (name, 0)
in
  if isend then false else
    eq_char_char (string_get_char_at (name, 0), '\[')
  // end of [if]
end // end of [atarray_name_test]

fn fprint_atarray_name
  {m:file_mode} (
  pf: fmlte (m, w) | out: &FILE m, name: string
) : void = let
//
fun aux
  {n:int}{i:nat | i <= n} (
  out: &FILE m, name: string n, i: size_t i
) : void = let
  val isnot = string_isnot_atend (name, i)
in
//
if isnot then let
  val c = name[i] in
  if c <> ']' then
    fprint1_char (pf | out, c); aux (out, name, i+1)
  // end of [if]
end // end of [if]
//
end // end of [aux]
//
val name = string1_of_string (name)
//
in
  if string_isnot_atend (name, 0) then aux (out, name, 1)
end // end of [fprint_atarray_name]

fn emit_typdef_rec
  {m:file_mode} (
  pf: fmlte (m, w) | out: &FILE m, lnames: labstrlst
) : void = let
//
fun aux (
  out: &FILE m, lnames: labstrlst
) : void = let
in
//
case+ lnames of
| LABSTRLSTcons (
    l, name, lnames
  ) => let
    val () = (
      case+ 0 of
      | _ when atarray_name_test name => let
          val () = fprint_atarray_name (pf | out, name)
          val () = fprint1_string (pf | out, " atslab_")
          val () = emit_label (pf | out, l)
          val () = fprint1_string (pf | out, "[] ;\n")
        in
          // empty
        end // end of [_ when ...]
      | _ => let
          val () = fprint1_string (pf | out, name)
          val () = fprint1_string (pf | out, " atslab_")
          val () = emit_label (pf | out, l)
          val () = fprint1_string (pf | out, " ;\n")
        in
          // empty
        end // end of [_]
    ) : void // end of [val]
  in
    aux (out, lnames)
  end // end of [LABSTRLSTcons]
| LABSTRLSTnil () => ()
//
end // end of [aux]
//
val () =
  fprint1_string (pf | out, "typedef\n")
val () =
  fprint1_string (pf | out, "struct {\n")
val () = aux (out, lnames)
val () = fprint1_string (pf | out, "}")
//
in
  (*nothing*)
end // end of [emit_typdef_rec]

fn emit_typdef_sum
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m, tag: int, names: strlst
) : void = let
//
fun aux (
  out: &FILE m, i: int, names: strlst
) : void = let
in
//
case+ names of
| list_cons
    (name, names) => let
    val () = fprint1_string (pf | out, name);
    val () = fprintf1_exn (pf | out, " atslab_%i", @(i))
    val () = fprint1_string (pf | out, " ;\n")
  in
    aux (out, i+1, names)
  end // end of [list_cons]
| list_nil () => ()
//
end // end of [aux]
//
in
//
case+ tag of
| _ when tag = 0 => begin
    fprint1_string (pf | out, "typedef struct {\n");
    aux (out, 0, names);
    fprint1_string (pf | out, "}")
  end // end of [0]
| _ when tag = 1 => begin
    fprint1_string (pf | out, "typedef struct {\n");
    fprint1_string (pf | out, "int tag ;\n");
    aux (out, 0, names);
    fprint1_string (pf | out, "}")
  end // end of [1]
| _ when tag = ~1 => begin
    fprint1_string (pf | out, "typedef struct {\n");
    fprint1_string (pf | out, "int tag ;\n");
    fprint1_string (pf | out, "char *name ;\n");
    aux (out, 0, names);
    fprint1_string (pf | out, "}")
  end // end of [~1]
| _ => begin
    prerr_interror ();
    prerr ": aux_sum_con: tag = "; prerr tag; prerr_newline ();
    $Err.abort {void} ()
  end // end of [_]
//
end // end of [emit_typdef_sum]

fn emit_typdeflst_free
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m, tds: typdeflst
) : int = let
//
fun aux (
  out: &FILE m, i: int, tds: typdeflst
) : int = let
in
//
case+ tds of
| ~TYPDEFLSTcons
    (tk, name_def, tds) => let
    val () =
      if i > 0 then fprint1_char (pf | out, '\n')
    // end of [val]
    val () = (
      case+ tk of
      | TYPKEYrec lnames => begin
          emit_typdef_rec (pf | out, lnames);
          fprintf1_exn (pf | out, " %s ;\n", @(name_def));
        end
      | TYPKEYsum (tag, names) => begin
          emit_typdef_sum (pf | out, tag, names);
          fprintf1_exn (pf | out, " %s ;\n", @(name_def));
        end
      | TYPKEYuni lnames => ()
    ) : void // end of [val]
  in
    aux (out, i+1, tds)
  end // end of [TYPDEFLSTcons]
| ~TYPDEFLSTnil () => (i)
//
end // end of [aux]
//
in
  aux (out, 0, tds)
end // end of [emit_typdeflst_free]

(* ****** ****** *)

fun emit_saspcstlst
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m, xs: !saspcstlst
) : int = let
//
fun aux (
  out: &FILE m, i: int, xs: !saspcstlst
) : int = let
in
//
case+ xs of
| list_vt_cons
    (x, !p_xs1) => let
    val s2c = x
    val- Some (fil) = s2cst_get_fil (s2c)
    val name = $Sym.symbol_name (s2cst_get_sym (s2c))
    val () = fprint1_string (pf | out, "int ")
    val () = emit_filename (pf | out, fil)
    val () = fprint1_string (pf | out, "__sasp__")
    val () = emit_identifier (pf | out, name)
    val () = fprint1_string (pf | out, " = 0 ;\n")
    val res = aux (out, i+1, !p_xs1)
  in
    fold@ (xs); res
  end // end of [list_vt_cons]
| list_vt_nil () => (fold@ (xs); i)
//
end // end of [aux]
//
in
  aux (out, 0, xs)
end // end of [emit_saspcstlst]

(* ****** ****** *)

fn emit_datcstlst
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m, s2cs: !datcstlst
) : int = let
//
fun aux_conlst (
  out: &FILE m, d2cs: d2conlst
) : void = let
in
//
case+ d2cs of
| D2CONLSTcons
   (d2c, d2cs) => let
    val () = 
      fprint1_string (
      pf | out, "ATSglobal(ats_sum_type, "
    )
    val () = emit_d2con (pf | out, d2c)
    val () = fprint1_string (pf | out, ") ;\n")
  in
    aux_conlst (out, d2cs)
  end
| D2CONLSTnil () => ()
//
end // end of [aux_conlst]
//
fn aux_cst (
  out: &FILE m, s2c: s2cst_t
) : void = (
  case+ s2cst_get_conlst (s2c) of
  | Some d2cs => aux_conlst (out, d2cs) | None () => ()
) // end of [aux_cst]
//
fun aux (
  out: &FILE m, i: int, s2cs: !datcstlst
) : int = let
in
//
case+ s2cs of
| DATCSTLSTcons
    (s2c, !p_s2cs1) => let
    val () = aux_cst (out, s2c)
    val res = aux (out, i+1, !p_s2cs1)
  in
    fold@ (s2cs); res
  end
| DATCSTLSTnil () => (fold@ (s2cs); i)
//
end // end of [aux]
//
in
  aux (out, 0, s2cs)
end // end of [emit_datcstlst]

(* ****** ****** *)

fn emit_exnconlst
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m, d2cs: !exnconlst
) : int = let
//
fun aux (
  out: &FILE m, i: int, d2cs: !exnconlst
) : int = let
in
//
case+ d2cs of
| EXNCONLSTcons
    (d2c, !p_d2cs1) => let
    val () =
      fprint1_string (
      pf | out, "ATSglobal(ats_exn_type, "
    ) // end of [val]
    val () = emit_d2con (pf | out, d2c)
    val () = fprint1_string (pf | out, ") ;\n")
    val res = aux (out, i+1, !p_d2cs1)
  in
    fold@ (d2cs); res
  end // end of [EXNCONLSTcons]
| EXNCONLSTnil () => (fold@ (d2cs); i)
//
end // end of [aux]
//
in
  aux (out, 0, d2cs)
end // end of [emit_exnconlst]

(* ****** ****** *)

fn emit_free_glocstlst
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m, xs: glocstlst
) : int = let
//
fun aux (
  out: &FILE m, i: int, xs: glocstlst
) : int = let
in
//
case+ xs of
| ~GLOCSTLSTcons_clo
    (d2c, xs) => let
    val () =
      fprint1_string (
      pf | out, "ATSglobal(ats_clo_ptr_type, "
    ) // end of [val]
    val () = emit_d2cst (pf | out, d2c)
    val () = fprint1_string (pf | out, ") ;\n")
  in
    aux (out, i+1, xs)
  end // end of [GLOCSTLSTcons_clo]
| ~GLOCSTLSTcons_fun
    (d2c, xs) => let
    val () =
      fprint1_string (
      pf | out, "ATSglobal(ats_fun_ptr_type, "
    ) // end of [val]
    val () = emit_d2cst (pf | out, d2c)
    val () = fprint1_string (pf | out, ") ;\n")
  in
    aux (out, i+1, xs)
  end // end of [GLOCSTLSTcons_fun]
| ~GLOCSTLSTcons_val
    (d2c, vp, xs) => let
    val () =
      fprint1_string (pf | out, "ATSglobal(")
    val () = emit_hityp (pf | out, vp.valprim_typ)
    val () = fprint1_string (pf | out, ", ")
    val () = emit_d2cst (pf | out, d2c)
    val () = fprint1_string (pf | out, ") ;\n")
  in
    aux (out, i+1, xs)
  end // end of [GLOCSTLSTcons_val]
| ~GLOCSTLSTnil () => i // end of [GLOCSTLSTnil]
//
end // end of [aux]
//
in
  aux (out, 0, xs)
end // end of [emit_free_glocstlst]

(* ****** ****** *)

fn emit_free_partvalst
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m, xs: partvalst
) : int = let
//
fun aux (
  out: &FILE m, i: int, xs: partvalst
) : int = let
in
//
case+ xs of
| ~PARTVALSTcons
    (name, vp, xs) => let
//
    val () = fprint1_string (pf | out, "/*\n")
//
    val () = fprint1_string (pf | out, "ATSstatic(")
    val () = emit_hityp (pf | out, vp.valprim_typ)
    val () = fprint1_string (pf | out, ", ")
    val () = fprint1_string (pf | out, name)
    val () = fprint1_string (pf | out, ") ;\n")
//
    val () = fprint1_string (pf | out, "*/\n")
//
  in
    aux (out, i+1, xs)
  end // end of [PARTVALSTcons]
| ~PARTVALSTnil () => (i)
//
end // end of [aux]
//
in
  aux (out, 0, xs)
end // end of [emit_free_partvalst]

(* ****** ****** *)

fn _emit_dynconset
  {m:file_mode} {l:addr} (
  pf_mod: fmlte (m, w)
, pf_fil: !FILE (m) @ l
| p_l: ptr (l), d2cs: dynconset
) : int = let
//
var i: int = 0
//
viewdef V = (FILE m @ l, int @ i)
dataviewtype ENV2
  (l:addr, i:addr) = ENV2con (l, i) of (ptr l, ptr i)
// end of [ENV2]
viewtypedef VT = ENV2 (l, i)
//
fn f_con (
  pf: !V | d2c: d2con_t, env: !VT
) : void = let
  prval @(pf_fil, pf_int) = pf
  val+ ENV2con (p_l, p_i)= env
  val i = !p_i; val () = (!p_i := i + 1)
//
  val () = fprint1_string (pf_mod | !p_l, "ATSextern_val(")
//
  val () = (
    case+ 0 of
    | _ when d2con_is_exn d2c => begin
        fprint1_string (pf_mod | !p_l, "ats_exn_type, ")
      end // end of [_ when ...]
    | _ => begin
        fprint1_string (pf_mod | !p_l, "ats_sum_type, ")
      end // end of [_]
  ) : void // end of [val]
  val () = emit_d2con (pf_mod | !p_l, d2c)
  val () = fprint1_string (pf_mod | !p_l, ") ;\n")
in
  pf := @(pf_fil, pf_int); fold@ env
end // end of [f_con]
//
val env = ENV2con (p_l, &i)
prval pf = @(pf_fil, view@ i)
val () = dynconset_foreach_main {V} {VT} (pf | d2cs, f_con, env)
prval () = (pf_fil := pf.0; view@ i := pf.1)
val+ ~ENV2con (_, _) = env
//
in
  i // the number of dyncons
end // end of [_emit_dynconset]

fn emit_dynconset
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m, d2cs: dynconset
) : int =
  _emit_dynconset (pf, view@ out | &out, d2cs)
// end of [emit_dynconset]

(* ****** ****** *)

#define HITARGSEP ", "

(* ****** ****** *)

fn emit_d2cst_fun_class // static/extern
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m, d2c: d2cst_t
) : void = let
  val issta = d2cst_is_extsta (d2c)
in
  if issta then
    fprint1_string (pf | out, "ATSstatic_fun")
   else
     fprint1_string (pf | out, "ATSextern_fun")        
   // end of [if]
end // end of [emit_d2cst_fun_class]

fn emit_d2cst_val_class // static/extern
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m, d2c: d2cst_t
) : void = let
  val issta = d2cst_is_extsta (d2c)
in
//
if issta then
  fprint1_string (pf | out, "ATSstatic_val")
else
  fprint1_string (pf | out, "ATSextern_val")        
//
end // end of [emit_d2cst_val_class]

(* ****** ****** *)

fn emit_d2cst_dec
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m, d2c: d2cst_t
) : void = let
//
val hit0 =
  d2cst_get_hityp_some (d2c)
//
val hit1 = hityp_decode (hit0)
//
macdef
f_isprf_mac () = let
  val () =
    fprint1_string (
    pf | out, "ATSextern_prf("
  ) // end of [val]
  val () = emit_d2cst (pf | out, d2c)
  val () = fprint1_string (pf | out, ") ;\n")
in
  (*nothing*)
end // end of [macdef]
//
macdef
f_isfun_FUNCLOclo_mac
  (hits_arg, hit_res) = let
(*
  val hits_arg = hityplst_encode ,(hits_arg)
  val hit_res = hityp_encode ,(hit_res)
*)
  val () =
    emit_d2cst_val_class (pf | out, d2c);
  val () =
    fprint1_string (pf | out, "(ats_ptr_type, ")
  val () = emit_d2cst (pf | out, d2c)
  val () = fprint1_string (pf | out, ") ;\n")
in
  (*nothing*)
end // end of [macdef]
//
macdef
f_isfun_FUNCLOfun_mac
  (hits_arg, hit_res) = let
(*
  val hits_arg = hityplst_encode ,(hits_arg)
  val hit_res = hityp_encode ,(hit_res)
*)
in
//
case+ 0 of
//
| _ when d2cst_is_fun (d2c) => let
    val hits_arg = hityplst_encode ,(hits_arg)
    val hit_res = hityp_encode ,(hit_res)
    val () = emit_d2cst_fun_class (pf | out, d2c)
    val () = fprint1_string (pf | out, "(")
    val () = emit_hityp (pf | out, hit_res)
    val () = fprint1_string (pf | out, ", ")
    val () = emit_d2cst (pf | out, d2c)
    val () = fprint1_string (pf | out, ") (")
    val () = emit_hityplst_sep (pf | out, hits_arg, HITARGSEP)
    val () = fprint1_string (pf | out, ") ;\n")
  in
    (*nothing*)
  end // end of [_ when ...]
//
| _ when d2cst_is_castfn d2c => () // casting function
//
| _ => let // function value
    val () =
      emit_d2cst_val_class (pf | out, d2c)
    val () =
      fprint1_string (pf | out, "(ats_ptr_type, ")
    val () = emit_d2cst (pf | out, d2c)
    val () = fprint1_string (pf | out, ") ;\n")
  in
    (*nothing*)
  end // end // end of [_]
//
end // end of [macdef]
//
macdef
f_isnotfun_mac () = let
  val () =
    emit_d2cst_val_class (pf | out, d2c);
  val () = fprint1_string (pf | out, "(");
  val () = emit_hityp (pf | out, hit0)
  val () = fprint1_string (pf | out, ", ")
  val () = emit_d2cst (pf | out, d2c)
  val () = fprint1_string (pf | out, ") ;\n")
in
  (*nothing*)
end // end of [_]
//
in // in of [let]
//
case+ 0 of
| _ when d2cst_is_proof d2c => ()
| _ when d2cst_is_extmac d2c => ()
| _ => (
  case+ hit1.hityp_node of
  | HITfun (fc, hits_arg, hit_res) => begin case+ fc of
    | $Syn.FUNCLOclo _ => f_isfun_FUNCLOclo_mac (hits_arg, hit_res)
    | $Syn.FUNCLOfun _ => f_isfun_FUNCLOfun_mac (hits_arg, hit_res)
    end // end of [HITfun]
  | _ => f_isnotfun_mac ()
  ) // end of [_]
//
end // end of [emit_d2cst_dec]

(* ****** ****** *)

fn emit_d2cst_dec_prfck
  {m:file_mode} ( // for terminating constants
  pf: fmlte (m, w)
| out: &FILE m, d2c: d2cst_t
) : void = let
//
val hit0 =
  d2cst_get_hityp_some (d2c)
//
val hit1 = hityp_decode (hit0)
//
macdef
f_isprf_mac () = let
  val () =
    fprint1_string (pf | out, "extern\n")
  val () =
    emit_hityp (pf | out, hityp_t_void)
  val () = fprint1_char (pf | out, ' ')
  val () = emit_d2cst (pf | out, d2c)
  val () = fprint1_string (pf | out, "_prfck (")
  val () = fprint1_string (pf | out, ") ;\n")
in
  (*nothing*)
end // end of [macdef]
//
in
//
case+ 0 of
| _ when d2cst_is_praxi d2c => ()
| _ when d2cst_is_prfun d2c => f_isprf_mac ()
| _ when d2cst_is_prval d2c => f_isprf_mac ()
| _ => () // needs some fixing later
//
end // end of [emit_d2cst_dec]

(* ****** ****** *)

fn _emit_dyncstset_proc
  {m:file_mode} {l:addr} (
  pf_mod: fmlte (m, w)
, pf_fil: !FILE (m) @ l
| p_l: ptr l, d2cs: dyncstset
, proc: (fmlte (m, w) | &FILE m, d2cst_t) -> void
) : int = let
//
var i: int = 0
//
viewdef V = (FILE m @ l, int @ i)
typedef fun_type (m:file_mode) =
  (fmlte (m, w) | &FILE m, d2cst_t) -> void
dataviewtype ENV3 (m: file_mode, l:addr, i:addr) =
  ENV3con (m, l, i) of (ptr l, ptr i, fun_type m)
viewtypedef VT = ENV3 (m, l, i)
//
fn f_cst (
  pf: !V | d2c: d2cst_t, env: !VT
) : void = let
  prval @(pf_fil, pf_int) = pf
  val+ ENV3con (p_l, p_i, proc)= env
  val i = !p_i; val () = (!p_i := i + 1)
  val () = proc (pf_mod | !p_l, d2c)
in
  pf := @(pf_fil, pf_int); fold@ env
end // end of [f_cst]
//
fn f_cst_if (
  pf: !V | d2c: d2cst_t, env: !VT
) : void = let
in
  case+ d2cst_get_decarg (d2c) of
  | list_cons _ => () | list_nil _ => f_cst (pf | d2c, env)
end // end of [f_cst_if]
//
val env = ENV3con (p_l, &i, proc)
//
prval pf = @(pf_fil, view@ i)
val () = dyncstset_foreach_main {V} {VT} (pf | d2cs, f_cst_if, env)
prval () = (pf_fil := pf.0; view@ i := pf.1)
//
val+ ~ENV3con (_, _, _) = env
//
in
  i // the number of dynamic constructors
end // end of [_emit_dyncstset]

fn emit_dyncstset
  {m:file_mode} (
  pf: fmlte (m, w) | out: &FILE m, d2cs: dyncstset
) : int =
  _emit_dyncstset_proc (pf, view@ out | &out, d2cs, emit_d2cst_dec)
// end of [emit_dyncstset]

fn emit_dyncstset_prfck
  {m:file_mode} (
  pf: fmlte (m, w) | out: &FILE m, d2cs: dyncstset
) : int =
  _emit_dyncstset_proc (pf, view@ out | &out, d2cs, emit_d2cst_dec_prfck)
// end of [emit_dyncstset_prfck]

(* ****** ****** *)

fn emit_instrlst_vt
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m, inss: !instrlst_vt
) : void = let
//
fun aux (
  out: &FILE m, i: int, inss: !instrlst_vt
) : int = let
in
//
case+ inss of
| list_vt_cons
    (ins, !p_inss1) => let
    val () = (
      if i > 0 then fprint1_char (pf | out, '\n')
    ) : void // endval
    val () = emit_instr (pf | out, ins)
    val res = aux (out, i+1, !p_inss1)
  in
    fold@ (inss); res
  end
| list_vt_nil () => (fold@ inss; i)
//
end // end of [aux]
//
val n = aux (out, 0, inss)
//
val () = if n > 0 then fprint_newline (pf | out)
//
in
  // empty
end // end of [emit_instrlst_vt]

(* ****** ****** *)

fun emit_funentry_lablst
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m, fls0: !funlablst_vt
) : void = let
in
//
case+ fls0 of
| list_vt_cons
    (fl, !p_fls) => let
    val prfck = funlab_get_prfck fl
    val entry = funlab_get_entry_some fl
    val () = (
      if prfck > 0 then
        fprint1_string (pf | out, "#ifdef _ATS_PROOFCHECK\n")
      // end of [if]
    ) : void // endval
    val () = emit_funentry (pf | out, entry)
    val () = fprint1_string (pf | out, "\n")
    val () = (
      if prfck > 0 then
        fprint1_string (pf | out, "#endif /* _ATS_PROOFCHECK */\n")
      // end of [if]
    ) : void // endval
    val () = fprint1_string (pf | out, "\n")
    val () = emit_funentry_lablst (pf | out, !p_fls)
  in
    fold@ (fls0)
  end // end of [list_cons]
| list_vt_nil () => fold@ (fls0)
//
end // end of [emit_funentry_lablst]

fun emit_funentry_lablst_prototype
  {m:file_mode} (
  pf: fmlte (m, w) | out: &FILE m, i: int, fls0: !funlablst_vt
) : int = let
in
//
case+ fls0 of
| list_vt_cons
    (fl, !p_fls) => let
    val entry = funlab_get_entry_some fl
    val () = emit_funentry_prototype (pf | out, entry)
    val res = emit_funentry_lablst_prototype (pf | out, i+1, !p_fls)
  in
    fold@ (fls0); res
  end // end of [list_vt_cons]
| list_vt_nil () => (fold@ (fls0); i)
//
end // end of [emit_funentry_lablst_prototype]

(* ****** ****** *)

fun instrlst_vt_tmpvarmap_gen
  (inss0: !instrlst_vt): tmpvarmap_vt = let
//
fun aux (
  m: &tmpvarmap_vt, inss0: !instrlst_vt
) : void = let
in
//
case+ inss0 of
| list_vt_cons
    (ins, !p_inss) => let
    val () = instr_tmpvarmap_add (m, ins)
    val () = aux (m, !p_inss)
  in
    fold@ (inss0)
  end // end of [list_vt_cons]
| list_vt_nil () => fold@ (inss0)
//
end // end of [aux]
//
var map = tmpvarmap_nil ()
//
in
  aux (map, inss0); map
end // end of [instrlst_vt_tmpvarmap_gen]

(* ****** ****** *)

fn emit_extvalist_dec
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m, exts: !extvalist
) : int = let
//
fun aux (
  out: &FILE m, i: int, exts: !extvalist
) : int = let
in
//
case+ exts of
| EXTVALLSTcons
    (name, vp, !p_exts1) => let
    val () = emit_hityp (pf | out, vp.valprim_typ)
    val () = fprintf1_exn (pf | out, " %s ;\n", @(name))
    val res = aux (out, i+1, !p_exts1)
  in
    fold@ exts; res
  end // end of [EXTVALLSTcons]
| EXTVALLSTnil () => (fold@ exts; i)
//
end // end of [aux]
//
in
  aux (out, 0, exts)
end // end of [emit_extvalist_dec]

fn emit_extvalist_markroot
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m, exts: !extvalist
) : int = let
//
fun aux (
  out: &FILE m, i: int, exts: !extvalist
) : int = let
in
//
case+ exts of
| EXTVALLSTcons
    (name, vp, !p_exts1) => let
    val () =
      fprint1_string (
      pf | out, "ATS_GC_MARKROOT (&"
     ) // end of [val]
    val () = fprint1_string (pf | out, name)
    val () = fprint1_string (pf | out, ", sizeof(")
    val () = emit_hityp (pf | out, vp.valprim_typ)
    val () = fprint1_string (pf | out, ")) ;\n")
    val res = aux (out, i+1, !p_exts1)
  in
    fold@ exts; res
  end
| EXTVALLSTnil () => (fold@ exts; i)
//
end // end of [aux]
//
in
  aux (out, 0, exts)
end // end of [emit_extvalist_markroot]

(* ****** ****** *)

fun emit_stafile_extcode
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m, fil: fil_t
) : void = let
//
val fil_sym = $Fil.filename_full_sym (fil)
val od2cs = $TR2Env.d2eclst_namespace_find (fil_sym)
val d2cs = (
  case+ od2cs of
  | ~Some_vt
      (d2cs) => d2cs
  | ~None_vt () => begin
      prerr_interror ();
      prerr ": emit_stafile_extcode: fil = "; $Fil.prerr_filename fil;
      prerr_newline ();
      $Err.abort {d2eclst} ()
    end // end of [None_vt]
) : d2eclst // end of [val]
//
fun aux (
  out: &FILE m, d2cs: d2eclst
) : void = let
in
//
case+ d2cs of
| list_cons
    (d2c, d2cs) => let
    val () = (
      case+ d2c.d2ec_node of
      | D2Cextcode (pos, code) =>
          if (pos >= 0) then () else fprint1_string (pf | out, code)
        // end of [D2Cextcode]
      | D2Cstaload (_qua, fil, _loaded, _loadflag, _d2cs) =>
          emit_stafile_extcode (pf | out, fil) // end of [D2Cstaload]
      | _ => ()
    ) : void // end of [val]
  in
    aux (out, d2cs)
  end // end of [list_cons]
| list_nil () => ()
//
end // end of [aux]
//
in
  aux (out, d2cs)
end // end of [emit_stafile_extcode]

fun emit_stafilelst_extcode
  {m:file_mode} (
  pf: fmlte (m, w) | out: &FILE m, fils: !stafilelst
) : void = let
in
//
case+ fils of
| STAFILELSTcons
    (fil, loadflag, !p_fils1) => let
    val () = emit_stafile_extcode (pf | out, fil)
    val () = emit_stafilelst_extcode (pf | out, !p_fils1)
  in
    fold@ (fils)
  end // end of [STAFILELSTcons]
| STAFILELSTnil () => fold@ (fils)
//
end (* end of [emit_stafilelst_extcode] *)

(* ****** ****** *)

fn emit_staload
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m
, fil: fil_t
, stafils: stafilelst
, s2cs: !datcstlst
, d2cs: !exnconlst
) : void = let
//
fun aux_staload_dec (
  out: &FILE m, fils: !stafilelst, i: int
) : void = let
in
//
case+ fils of
| STAFILELSTcons
    (fil, loadflag, !p_fils1) => let
    val () =
      if (loadflag = 0) then fprint1_string (pf | out, "// ")
    // end of [val]
    val () = fprint1_string (pf | out, "extern ats_void_type ")
    val () = emit_filename (pf | out, fil)
    val () = fprint1_string (pf | out, "__staload (void) ;\n")
    val () = aux_staload_dec (out, !p_fils1, i+1)
  in
    fold@ (fils)
  end // end of [STAFILELSTcons]
| STAFILELSTnil () => let
    val () = if i > 0 then fprint_char (pf | out, '\n')
  in
    fold@ (fils)
  end // [STAFIELSTnil]
//
end // end of [ats_staload_dec]
//
fun aux_staload_app (
  out: &FILE m, fils: !stafilelst, i: int
) : void = let
in
//
case+ fils of
| STAFILELSTcons
    (fil, loadflag, !p_fils1) => let
    val () =
      if (loadflag = 0) then fprint1_string (pf | out, "// ")
    // end of [val]
    val () = emit_filename (pf | out, fil)
    val () = fprint1_string (pf | out, "__staload () ;\n")
    val () = aux_staload_app (out, !p_fils1, i+1)
  in
    fold@ (fils)
  end // end of [STAFILELSTcons]
| STAFILELSTnil () => let
    val () = (
      if i > 0 then fprint_char (pf | out, '\n')
    ) : void // endval
  in
    fold@ (fils)
  end // end of [STAFILELSTnil]
//
end // end of [ats_staload_app]
//
fun aux_staload_datcstlst (
  out: &FILE m, s2cs: !datcstlst
) : int = let
  fun aux_conlst (
    out: &FILE m, d2cs: d2conlst
  ) : void = let
  in
    case+ d2cs of
    | D2CONLSTcons
        (d2c, d2cs) => let
        val () = (
          // only needed for a constructor with no arguments!
          if d2con_get_arity_real (d2c) > 0 then fprint1_string (pf | out, "// ")
        ) // end of [val]
        val () = emit_d2con (pf | out, d2c);
        val tag = d2con_get_tag (d2c)
        val () = fprintf1_exn (pf | out, ".tag = %i ;\n", @(tag))
      in
        aux_conlst (out, d2cs)
      end // end of [D2CONLSTcons]
    | D2CONLSTnil () => ()
  end // end of [aux_conlst]
  fn aux_cst (
    out: &FILE m, s2c: s2cst_t
  ) : void = (
    case+ s2cst_get_conlst (s2c) of
    | Some d2cs => aux_conlst (out, d2cs) | None () => ()
  ) // end of [aux_cst]
  fun aux (
    out: &FILE m, s2cs: !datcstlst, i: int
  ) : int = let
  in
    case+ s2cs of
    | DATCSTLSTcons
        (s2c, !p_s2cs1) => let
        val () = aux_cst (out, s2c)
        val res = aux (out, !p_s2cs1, i+1)
      in
        fold@ (s2cs); res
      end // end of [DATCSTLSTcons]
    | DATCSTLSTnil () => (fold@ (s2cs); i)
  end // end of [aux]
in
  aux (out, s2cs, 0)
end // end of [aux_staload_datcstlst]
//
fun aux_staload_exnconlst (
  out: &FILE m, d2cs: !exnconlst
) : int = let
//
fun aux (
  out: &FILE m, d2cs: !exnconlst, i: int
) : int = let
in
//
case+ d2cs of
| EXNCONLSTcons
    (d2c, !p_d2cs1) => let
    val () = emit_d2con (pf | out, d2c)
    val () =
      fprint1_string (
      pf | out, ".tag = ats_exception_con_tag_new () ;\n"
    ) // end of [fprint1_string]
    val () = emit_d2con (pf | out, d2c)
    val () = fprint1_string (pf | out, ".name = \"")
(*
    val () = $Fil.fprint1_string_filename (pf | out, d2con_fil_get d2c)
    val () = fprint1_string (pf | out, "::")
    val () = fprint1_string_d2con (pf | out, d2c)
*)
    val () = emit_d2con (pf | out, d2c)
    val () = fprint1_string (pf | out, "\" ;\n")
    val res = aux (out, !p_d2cs1, i+1)
  in
    fold@ (d2cs); res
   end // end of [EXNCONLSTcons]
| EXNCONLSTnil () => (fold@ (d2cs); i)
//
end // end of [aux]
//
in
  aux (out, d2cs, 0)
end // end of [aux_staload_exnconlst]
(*  
//
// *_staload function should always be defined!
//
val () = fprint1_string (pf | out, "#ifndef _ATS_STALOADFUN_NONE\n")
//
*)
val () = aux_staload_dec (out, stafils, 0)
//
val () = fprint1_string (pf | out, "ats_void_type\n")
val () = emit_filename (pf | out, fil)
val () = fprint1_string (pf | out, "__staload () {\n")
//
val () = fprint1_string (pf | out, "static int ")
val () = emit_filename (pf | out, fil)
val () = fprint1_string (pf | out, "__staload_flag = 0 ;\n")
val () = fprint1_string (pf | out, "if (");
val () = emit_filename (pf | out, fil)
val () = fprint1_string (pf | out, "__staload_flag) return ;\n")
val () = emit_filename (pf | out, fil)
val () = fprint1_string (pf | out, "__staload_flag = 1 ;\n\n")
//
val () = aux_staload_app (out, stafils, 0)
//
val () = stafilelst_free (stafils)
//
val _(*int*) = aux_staload_datcstlst (out, s2cs)
val _(*int*) = aux_staload_exnconlst (out, d2cs)
//
val () = fprint1_string (pf | out, "return ;\n")
val () = fprint1_string (pf | out, "} /* staload function */\n\n")
(*
val () = fprint1_string (pf | out, "#endif /* [_ATS_STALOADFUN_NONE] */\n\n")
*)
in
  (*DoNothing*)
end // end of [emit_staload]

(* ****** ****** *)

fn emit_dynload
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m
, dynloadflag: int
, fil: fil_t
, res: !instrlst_vt
, tmps: !tmpvarmap_vt
, exts: !extvalist
) : void = let
//
// HX: code for dynamic loading
//
val dynfils = the_dynfilelst_get ()
val () =
  aux_dynload_dec (out, dynfils, 0) where
{
  fun aux_dynload_dec (
    out: &FILE m, fils: !dynfilelst, i: int
  ) : void = let
  in
    case+ fils of
    | DYNFILELSTcons
        (fil, !p_fils1) => let
//
        val () = fprint1_string (pf | out, "ats_int_type ")
        val () = emit_filename (pf | out, fil)
        val () = fprint1_string (pf | out, "__dynload_flag = 0 ;\n")
//
        val () = fprint1_string (pf | out, "extern ats_void_type ")
        val () = emit_filename (pf | out, fil)
        val () = fprint1_string (pf | out, "__dynload (void) ;\n")
//
        val () = aux_dynload_dec (out, !p_fils1, i + 1)
      in
        fold@ fils
      end // end of [DYNFILELSTcons]
    | DYNFILELSTnil () => let
        val () = (
          if i > 0 then fprint_char (pf | out, '\n')
        ) : void // end of [val]
      in
        fold@ (fils)
      end // end of [DYNFILELSTnil]
  end // end of [aux_dynload_dec]
} (* end of [where] // end of [val] *)
//
val () = dynfilelst_free (dynfils)
//
val () =
  fprint1_string (pf | out, "// dynload flag declaration\n")
//
val () = let
  val () = if dynloadflag = 0 then fprint1_string (pf | out, "// ")
  val () = fprint1_string (pf | out, "extern ats_int_type ")
  val () = emit_filename (pf | out, fil)
  val () = fprint1_string (pf | out, "__dynload_flag ;\n\n")
in
  (*nothing*)
end // end of [val]
//
val () = fprint1_string (pf | out, "ats_void_type\n")
val () = emit_filename (pf | out, fil)
val () = fprint1_string (pf | out, "__dynload () {\n")
//
val () = let
  val () =
    if dynloadflag = 0 then fprint1_string (pf | out, "// ")
  val () = emit_filename (pf | out, fil)
  val () = fprint1_string (pf | out, "__dynload_flag = 1 ;\n")
in
  // empty
end // end of [val]
//
// HX: code for static loading
//
val () = emit_filename (pf | out, fil)
val () = fprint1_string (pf | out, "__staload () ;\n\n")
//
// HX: code for termination checking
//
val () =
  fprint1_string (pf | out, "#ifdef _ATS_PROOFCHECK\n")
// end of [val]
//
stavar l_out: addr; val p_out: ptr l_out = &out
val () =
  dyncstset_foreach_main
    {FILE m @ l_out} {ptr l_out} (
    view@ out | the_dyncstset_get (), f, p_out
  ) where {
    fn f (
      pf_out: !FILE m @ l_out
    | d2c: d2cst_t, p_out: !ptr l_out
    ) : void = let
      val () = (
        case+ 0 of
        | _ when d2cst_is_praxi (d2c) => ()
        | _ when d2cst_is_prfun (d2c) => begin
            emit_d2cst (pf | !p_out, d2c); fprint1_string (pf | !p_out, "_prfck () ;\n")
          end // end of [_]
        | _ when d2cst_is_prval (d2c) => begin
            emit_d2cst (pf | !p_out, d2c); fprint1_string (pf | !p_out, "_prfck () ;\n")
          end // end of [_]
        | _ => () // should nonproof terminating functions be checked as well?
      ) : void // end of [val]
    in
      // empty
    end // end of [f]
  } // end of [where]
//
val () =
  fprint1_string (pf | out, "#endif /* _ATS_PROOFCHECK */\n")
// end of [val]
//
// HX: code marking GC roots
//
val () = fprint1_string
  (pf | out, "\n/* marking static variables for GC */\n")
val _(*n*) = emit_tmpvarmap_markroot (pf | out, tmps)
val () = fprint1_string
  (pf | out, "\n/* marking external values for GC */\n")
val _(*n*) = emit_extvalist_markroot (pf | out, exts)
//
val () = fprint1_string
  (pf | out, "\n/* code for dynamic loading */\n")
val () = emit_instrlst_vt (pf | out, res)
//
val () = fprint1_string (pf | out, "return ;\n")
val () = fprint1_string (pf | out, "} /* end of [dynload function] */\n\n")
//
// HX: this is used for explicit dynamic loading
//
val () = let
  val name = $Glo.atsopt_dynloadfun_name_get () // ATS_DYNLOADFUN_NAME
in
//
case+ 0 of
| _ when stropt_is_some name => let
    val name = stropt_unsome name
    val () = fprintf1_exn (pf | out, "ats_void_type %s () {\n", @(name))
    val () = emit_filename (pf | out, fil)
    val () = fprint1_string (pf | out, "__dynload () ; return ;\n}\n\n")
  in
    // empty
  end // end of [_ when ...]
  | _ => () // end of [_]
//
end // end of [val]
//
in
  (*nothing*)
end // end of [emit_dynload]

(* ****** ****** *)

fn emit_extypelst_free
  {m:file_mode} (
  pf: fmlte (m, w) | out: &FILE m, ets: extypelst
) : int = let
//
fun aux (
  out: &FILE m, i: int, ets: extypelst
) : int = let
in
//
case+ ets of
| ~EXTYPELSTcons
    (name, hit_def, ets) => let
    val hit_def = hityp_decode hit_def
    val HITNAM (knd, def) = hit_def.hityp_name
    val () =
      fprintf1_exn (pf | out, "typedef %s ", @(def))
    val () = if knd > 0 then fprint1_char (pf | out, '*')
    val () = fprintf1_exn (pf | out, "%s ;\n", @(name))
  in
    aux (out, i + 1, ets)
  end // end of [EXTYPELSTcons]
| ~EXTYPELSTnil () => (i)
//
end // end of [aux]
//
in
  aux (out, 0, ets)
end // end of [emit_extypelst_free]

(* ****** ****** *)

fn emit_extcodelst
  {m:file_mode} (
  pf: fmlte (m, w)
| out: &FILE m
, pos0: int (* top(0), mid(1), bot(2) *)
, xs0: &extcodelst
) : int = let
//
fn test (
   pos0: int, pos: int
) : bool = let
in
  if pos0 = 0
    then pos <= 0 // pos = 0/~1
    else (if pos0 = 1 then pos = 1 else true)
  // end of [if]
end (* end of [test] *)
//
fun aux_main (
  out: &FILE m
, pos0: int
, xs0: &extcodelst
, i: &int
) : void = let
in
//
case+ xs0 of
| EXTCODELSTcons
    (loc, pos, code, !p_xs) => let
  in
    if test (pos0, pos) then let
//
      val gline = $Deb.gline_flag_get ()
      val () = if gline >= 1 then
        $Loc.fprint_line_pragma (pf | out, loc)
      // end of [val]
//
      val () = fprint1_string (pf | out, code)
      val xs = !p_xs
      val () = free@ (xs0)
      val () = xs0 := xs
      val () = i := i + 1
    in
      aux_main (out, pos0, xs0, i)
    end else let
      val () =
        aux_main (out, pos0, !p_xs, i) in fold@ (xs0)
      // end of [val]
    end (* end of [if] *)
  end // end of [EXTCODELSTcons]
| EXTCODELSTnil () => fold@ (xs0)
//
end // end of [aux]
//
var i: int = 0
//
in
  aux_main (out, pos0, xs0, i); i
end // end of [emit_extcodelst]

(* ****** ****** *)

fn main_void_is_implemented (): bool = let
  val d2c = $SDC.d2cstref_get_cst ($SDC.Ats_main_void)
in
  case+ the_topcstctx_find (d2c) of
  | ~Some_vt _ => true | ~None_vt () => false
end // end of [main_void_is_implemented]

fn main_argc_argv_is_implemented (): bool = let
  val d2c = $SDC.d2cstref_get_cst ($SDC.Ats_main_argc_argv)
in
  case+ the_topcstctx_find (d2c) of
  | ~Some_vt _ => true | ~None_vt () => false
end // end of [main_argc_argv_is_implemented]

fn main_dummy_is_implemented (): bool = let
  val d2c = $SDC.d2cstref_get_cst ($SDC.Ats_main_dummy)
in
  case+ the_topcstctx_find (d2c) of
  | ~Some_vt _ => true | ~None_vt () => false
end // end of [main_dummy_is_implemented]

(* ****** ****** *)

#define MAINATS_NONE ~1
#define MAINATS_VOID 0
#define MAINATS_ARGC_ARGV 1
#define MAINATS_DUMMY 2

fn mainatsknd_get (): int = let
  val is_main_void = main_void_is_implemented ()
  val is_main_argc_argv = main_argc_argv_is_implemented ()
in
  if is_main_void then begin
    if not (is_main_argc_argv)
      then MAINATS_VOID else let
      val () = prerr "error(ccomp)"
      val () = prerr ": it is not allowed to implement both [main_void] and [main_argc_argv]"
      val () = prerr_newline ()
    in
      $Err.abort {int} ()
    end // end of [if]
  end else begin
    if is_main_argc_argv then MAINATS_ARGC_ARGV else (
      if main_dummy_is_implemented () then MAINATS_DUMMY else MAINATS_NONE
    ) // end of [if]
  end (* end of [if] *)
end // end of [mainatsknd_get]

(* ****** ****** *)

implement
ccomp_main
(
  pf | flag, out, fil, hids
) = let
  var res: instrlst_vt = list_vt_nil ()
  val () = ccomp_declst (res, hids)
  val () = the_dynctx_free ()
  val fls: funlablst_vt = funentry_get_lablst ()
  val res = $Lst.list_vt_reverse (res)
//
  val () = emit_time_stamp (pf | out)
  val () = emit_include_header (pf | out)
  val () = if flag > 0 then emit_include_cats (pf | out)
//
// HX: including prologues in staloaded files
//
  val stafils = the_stafilelst_get ()
//
  val () = let
    val () =
      fprint1_string (
      pf | out, "/* prologues from statically loaded files */\n"
    ) // end of [val]
    val () = emit_stafilelst_extcode (pf | out, stafils)
  in
    (*nothing*)
  end // end of [val]
//
// HX: including external codes at top position
//
  var extcodes = the_extcodelst_get ()
//
  val () =
    fprint1_string (
    pf | out, "/* external codes at top */\n"
  ) // end of [val]
  val n = emit_extcodelst (pf | out, 0(*top*), extcodes)
  val () = if n > 0 then fprint1_char (pf | out, '\n')
//
// HX: declaring type definitions
//
  val () = let
    val () =
      fprint1_string (
      pf | out, "/* type definitions */\n"
    ) // end of [val]
    val n =
      emit_typdeflst_free (pf | out, typdeflst_get ())
    // end of [val]
  in
    if n > 0 then fprint1_char (pf | out, '\n')
  end // end of [val]
//
// HX: declaring external type definitions
//
  val () = let
    val () =
      fprint1_string (
      pf | out, "/* external typedefs */\n"
    ) // end of [val]
    val ets = the_extypelst_get ()
    val n = emit_extypelst_free (pf | out, ets)
  in
    if n > 0 then fprint1_char (pf | out, '\n')
  end // end of [val]
//
// HX: declaring external dynamic constructors
//
  val () =
    if (flag > 0) then let
    val () =
      fprint1_string (pf | out
    , "/* external dynamic constructor declarations */\n"
    ) // end of [val]
    val n = emit_dynconset (pf | out, the_dynconset_get ())
  in
    if n > 0 then fprint1_char (pf | out, '\n')
  end  // end of [val]
//
// HX: declaring external dynamic constants
//
  val () =
    if (flag > 0) then let
    val () =
      fprint1_string (pf | out
    , "/* external dynamic constant declarations */\n"
    ) // end of [val]
    val n = emit_dyncstset (pf | out, the_dyncstset_get ())
  in
    if n > 0 then fprint1_char (pf | out, '\n')
  end // end of [val]
//
// HX: declaring dynamic terminating constants
//
  val () =
    if (flag > 0) then let
    val () =
      fprint1_string (pf | out
    , "/* external dynamic terminating constant declarations */\n"
    ) // end of [val]
    val () =
      fprint1_string (pf | out, "#ifdef _ATS_PROOFCHECK\n")
    val n =
      emit_dyncstset_prfck (pf | out, the_dyncstset_get ())
    val () =
      if n = 0 then fprint1_string (pf | out, "/* empty */\n")
    val () =
      fprint1_string (pf | out, "#endif /* _ATS_PROOFCHECK */\n\n")
  in
    // empty
  end // end of [val]
//
// HX: assuming abstract types
//
  val s2cs = the_saspcstlst_get ()
  val () = let
    val () =
      fprint1_string (
      pf | out, "/* assuming abstract types */\n"
    ) // end of [val]
    val n = emit_saspcstlst (pf | out, s2cs)
  in
    if n > 0 then fprint1_char (pf | out, '\n')
  end
  val () = saspcstlst_free (s2cs)
//
// HX: declaring datatype constructors
//
  val datcsts = the_datcstlst_get ()
  val () = let
    val () =
      fprint1_string (
      pf | out, "/* sum constructor declarations */\n"
    ) // end of [val]
    val n = emit_datcstlst (pf | out, datcsts)
  in
    if n > 0 then fprint1_char (pf | out, '\n')
  end // end of [val]
//
// HX: declaring exception constructors
//
  val exncons = the_exnconlst_get ()
  val () = let
    val () =
      fprint1_string (
      pf | out, "/* exn constructor declarations */\n"
    ) // end of [val]
    val n = emit_exnconlst (pf | out, exncons)
  in
    if n > 0 then fprint1_char (pf | out, '\n')
  end // end of [val]
//
// HX: declaring implemented non-functional constants
//
  val () = if (flag > 0) then let
    val glocstlst = the_glocstlst_get ()
    val () =
      fprint1_string (pf | out
    , "/* global dynamic (non-functional) constant declarations */\n"
    ) // end of [val]
    val n = emit_free_glocstlst (pf | out, glocstlst)
    val () = if n > 0 then fprint1_char (pf | out, '\n')
  in
    // nothing
  end // end of [if] // end of [val]
//
// HX: declaring implemented static functional constants
//
  val () = if (flag > 0) then let
    val () =
      fprint1_string (
      pf | out, "/* internal function declarations */\n"
    ) // end of [val]
    val n = emit_funentry_lablst_prototype (pf | out, 0, fls)
    val () = if n > 0 then fprint1_char (pf | out, '\n')
  in
    // empty
  end // end of [val]
//
// HX: declaring implemented partial value templates
//
  val () =
    if (flag > 0) then let
    val partvalst = the_partvalst_get ()
    val () =
      fprint1_string (pf | out
    , "/* partial value template declarations */\n"
    ) // end of [val]
    val n = emit_free_partvalst (pf | out, partvalst)
    val () = if n > 0 then fprint1_char (pf | out, '\n')
  in
    // nothing
  end // end of [val]
//
// HX: declaring static temporary variables
//
  val tmps_static = instrlst_vt_tmpvarmap_gen (res)
  val () = if (flag > 0) then let // static variable declarations
    val () =
      fprint1_string (
      pf | out, "/* static temporary variable declarations */\n"
    ) // end of [val]
    val n = emit_tmpvarmap_dec_static (pf | out, tmps_static)
    val () = if n > 0 then fprint1_char (pf | out, '\n')
  in
    // empty
  end // end of [if] // end of [val]
//
// HX: declaring external variables
//
  val extvals = the_extvalist_get ()
  val () =
    if (flag > 0) then let // external variable declarations
    val () =
      fprint1_string (
      pf | out, "/* external value variable declarations */\n\n"
    ) // end of [val]
    val n = emit_extvalist_dec (pf | out, extvals)
    val () = if n > 0 then fprint1_char (pf | out, '\n')
  in
    // empty
  end // end of [if] // end of [val]
//
  val fls = (
    if (flag > 0) then let
      val () =
        fprint1_string (
        pf | out, "/* function implementations */\n\n"
      ) // edn of [val]
      val () = emit_funentry_lablst (pf | out, fls)
    in
      fls
    end else begin
      fls
    end // end of [if]
  ) : funlablst_vt
//
  val () = let
    val () =
      fprint1_string (
      pf | out, "/* static load function */\n\n"
    ) // end of [val]
    val () =
      emit_staload (pf | out, fil, stafils, datcsts, exncons)
    // end of [val]
  in
    // empty
  end // end of [val]
//
  val mainatsknd = mainatsknd_get ()
//
(*
  val () = begin
    print "ccomp_main: mainatsknd = "; print mainatsknd; print_newline ()
  end // end of [val]
*)
//
  val res = (
    if flag > 0 then let // defining the dynload function
      val dynloadflag = (
        if mainatsknd >= 0 then 0 else $Glo.atsopt_dynloadflag_get ()
      ) : int // end of [val]
      val () =
        fprint1_string (
        pf | out, "/* dynamic load function */\n\n"
      ) // end of [val]
      val () =
        emit_dynload (
        pf | out, dynloadflag, fil, res, tmps_static, extvals
      ) // end of [val]
    in
      res
    end else begin
      res
    end // end of [if]
  ) : instrlst_vt
//
  val () =
    $Lst.list_vt_free__boxed (res)
  val () = tmpvarmap_free (tmps_static)
  val () = extvalist_free (extvals)
//
  val () = (
    case+ 0 of
    | _ when
        mainatsknd >= 0 => (
        emit_mainfun (pf | out, fil); fprint1_char (pf | out, '\n')
      ) // end of [_ when ...]
    | _ => () // end of [_]
  ) : void // end of [val]
//
  val () = $Lst.list_vt_free__boxed (fls)
//
// HX: including external codes at mid position
//
  val () =
    fprint1_string (
    pf | out, "/* external codes at mid */\n"
  ) // end of [val]
  val n = emit_extcodelst (pf | out, 1(*mid*), extcodes)
  val () = if n > 0 then fprint1_char (pf | out, '\n')
//
// HX: including external codes at bot position
//
  val () =
    fprint1_string (
    pf | out, "/* external codes at bot */\n"
  ) // end of [val]
  val n = emit_extcodelst (pf | out, 2(*bot*), extcodes)
  val () = if n > 0 then fprint1_char (pf | out, '\n')
//
  val () = datcstlst_free (datcsts)
  val () = exnconlst_free (exncons)
  val () = extcodelst_free (extcodes)
//
in
  // empty
end // end of [ccomp_main]

(* ****** ****** *)

(* end of [ats_ccomp_main.dats] *)
