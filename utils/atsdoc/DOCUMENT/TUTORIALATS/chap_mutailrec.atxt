%{
//
dynload "libatsdoc/dynloadall.dats"
#include "utils/atsdoc/DOCUMENT/TUTORIALATS/tutorialatxt.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from chap_mutailrec.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="mutailrec">
#title("Mutual Tail-Recursion")

#para("\

Mutually tail-recursive functions are commonly encountered in practice.
Assume that #emph("foo") and #emph("bar") are two mutually defined
functions. In the body of either #emph("foo") or #emph("bar"), a tail-call
to #emph("foo") or #emph("bar") is referred to as a mutually tail-recursive
call. If every call to #emph("foo") or #emph("bar") in the bodies of
#emph("foo") and #emph("bar") are tail-call, then #emph("foo") and
#emph("bar") are mutually tail-recursive.  Mutual recursion involving more
functions can be defined similarly.  As an example, the following two
functions #code("isEvn") and #code("isOdd") are defined mutually
recursively:

#atscode_extract("\
fun isEvn (n: int): bool = if n > 0 then isOdd (n-1) else true
and isOdd (n: int): bool = if n > 0 then isEvn (n-1) else false
")

The call to #code("isOdd") in the body of #code("isEvn") is
a mutually tail-recursive call, and the call to #code("isEvn")
in the body of #code("isOdd") is also a a mutually tail-recursive call.
Therefore, #code("isEvn") and #code("isOdd") are mutually tail-recursive.
")#comment("para")

#para("\

In order to turn mutually recursive tail-calls into jumps, the bodies of
the involved mutually recursive functions need to be combined. The keyword
#code("fn*") in ATS is introduced precisely for this purpose. For instance,
let us replace #code("fun") with #code("fn*") in the code above:

#atscode_extract("\
fn* isEvn (n: int): bool = if n > 0 then isOdd (n-1) else true
and isOdd (n: int): bool = if n > 0 then isEvn (n-1) else false
")

Then the following C code is essentially what is generated from compiling
these two mutually defined functions:

#atscode("\
bool isEvnisOdd (int tag, int n) {

bool res ;

switch (tag) {
  0: goto isEvn ;
  1: goto isOdd ;
  default : exit (1) ;
}

isEvn: if (n > 0) { n = n - 1; goto isodd; } else { res = true; goto done; }
isOdd: if (n > 0) { n = n - 1; goto isEvn; } else { res = false; goto done; }

done: return res ;

} /* end of [isEvnisOdd] */

bool isEvn (int n) { return isEvnisOdd (0, n) ; }
bool isOdd (int n) { return isEvnisOdd (1, n) ; }

")

Note that mutually recursive functions can be combined in such a manner
only if they all have the same return type. In the above case, both
#code("isEvn") and #code("isOdd") have the same return type #code("bool").

")#comment("para")

#para("\

When translating C code involving embedded loops, we often encounter the
need for mutual tail-recursion. For example, the following C code prints
out some ordered pairs of digits:

#atscode('\
int main (
  int argc, char *argv[]
) {
  int i, j ;
  for (i = 0; i <= 9; i += 1) {
    for (j = i; j <= 9; j += 1) {
      if (i < j) printf (", ") ; printf ("(%i, %i)", i, j) ;
    } /* for */
    printf ("\n") ;
  } /* for */
  return 0 ;
}
')

A straightforward translation of the C code into ATS (in the style of
functional programming) can be done as follows:

#atscode_extract('\
implement
main (argc, argv) = let
  fn* loop1
    {i:nat | i <= 10} (i: int i): void =
    if i <= 9 then loop2 (i, i) else ()
  // end of [loop1]

  and loop2
    {i,j:nat | i <= 9; j <= 10} (i: int i, j: int j): void =
    if j <= 9 then (
      if i < j then (
        print ", "; printf ("(%i, %i)", @(i, j)); loop2 (i, j+1)
      ) // end of [if]
    ) else (
      print_newline (); loop1 (i+1)
    ) // end of [if]
  // end of [loop2]
in
  loop1 (0)
end // end of [main]
')

Evidently, #code("loop1") and #code("loop2") are defined mutually
tail-recursively. The use of the keyword #code("fn*") ensures that these
two functions are translated into the equivalent of two loops in C, which
require only a fixed amount of stack space to run.

")#comment("para")

</chapter><!--"mutailrec"-->

#comment(" ****** ****** ")

#comment(" end of [chap_mutailrec.atxt] ")

%{
implement main () = {
//
  val filr =
    $STDIO.fopen_ref_exn ("CODE/chap_mutailrec.dats", file_mode_w)
  val () = fprint_theCodeLst (filr)
  val () = $STDIO.fclose_exn (filr)
//
  val () = fprint_filsub (stdout_ref, "chap_mutailrec_atxt.txt")
//
}
%}
