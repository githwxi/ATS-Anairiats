%{
//
dynload "libatsdoc/dynloadall.dats"
#include "utils/atsdoc/DOCUMENT/TUTORIALATS/tutorialatxt.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from chap_mainats.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="mainats">
#title("The Program Entry Point: mainats")

#para("\

There are two special functions of the name
#code("main_void") and #code("main_argc_argv") that are given the
following interfaces:

#atscode('\
fun main_void (): void = "mainats"
overload main with main_void

fun main_argc_argv {n:int | n >= 1}
  (argc: int n, argv: &(@[string][n])): void = "mainats"
overload main with main_argc_argv
')

The symbol #code("main") is overloaded with both of these functions. In
addition, the global name #code("mainats") is assigned to both of
them. When a function in ATS is translated into one in C, the global name
of the function, if ever assgined, is used to refer to its translation in
C.

")#comment("para")

#para("\

The interface for #code("main_argc_argv") indicates that the function takes
as its arguments an integer #emph("argc") greater than 0 and an array
#emph("argv") of size #emph("argc") in which each element is a string, and
returns no value.  The syntax #code("argv: &amp;(@[string][n]") means that
#code("argv") is a call-by-reference argument. If we followed the like of
syntax in C++, then this would be written as something like
#code("&amp;argv: @[string][n]").

")#comment("para")

#para("\

To turn ATS source code into an executable, the function
#comment("mainats") is required to be present in the C code translated from
the ATS code (as it is called within the #code("main") function in
C). Normally, this means that either #code("main_void") or
#code("main_argc_argv") needs to be implemented in the ATS code (that is to
be turned into an executable). However, in certain situations, it may make
sense to implement #code("mainats") in C directly. Note that the interface
for #code("mainats") in C is:

#atscode("\
extern ats_void_type mainats (ats_int_type, ats_ptr_type) ;
")

where #code("ats_void_type"), #code("ats_int_type") and
#code("ats_ptr_type") are just aliases for #code("void"), #code("int") and
#code("void*"), respectively.

")#comment("para")

#para("\

As an example, the following ATS program echos onto the standard output the
given command line:

#atscode("\
implement
main (argc, argv) = let
  fun loop {n,i:nat | i <= n} // [loop] is tail-recursive
    (i: int i, argc: int n, argv: &(@[string][n])): void =
    if i < argc then begin
      if i > 0 then print (' '); print argv.[i]; loop (i+1, argc, argv)
    end // end of [if]
  // end of [loop]
in
  loop (0, argc, argv); print_newline ()
end // end of [main]
")
")#comment("para")

#para("\

If #code("mainats") needs to be implemented in C, the proof function
#code("main_dummy") should be implemented as follows:

#atscode("\
implement main_dummy () = ()
")

This implementation is solely for telling the ATS compiler that
#code("mainats") is expected to be implemented in C directly so that the
compiler can generate proper code to handle the situation.  As an example,
I present as follows a typical scenario in GTK+ programming, where the
function #code("gtk_init") needs to be called to modify the arguments passed
from the given command line:

")#comment("para")

#para("\

#atscode('\
//
// some function implemented in ATS
//
extern fun main_work // implemented elsewhere
  {n:pos} (argc: int n, argv: &(@[string][n])): void = "main_work"
// end of [main_work]

%{^
// %{^ : the embedded C code is placed at the top
extern ats_void_type mainats (ats_int_type, ats_ptr_type) ;
%} // end of [%{^]

implement main_dummy () = () // indicating [mainats] being implemented in C

%{$
// %{$ : the embedded C code is placed at the bottom
ats_void_type
mainats (
  ats_int_type argc, ats_ptr_type argv
) {
  gtk_init ((int*)&argc, (char ***)&argv) ; main_work (argc, argv) ; return ;
} /* end of [mainats] */

%} // end of [%{$]
')

")#comment("para")

</chapter><!--"mainats"-->

#comment(" ****** ****** ")

#comment(" end of [chap_mainats.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "chap_mainats_atxt.txt")
%}
