%{
//
dynload "libatsdoc/dynloadall.dats"
#include "utils/atsdoc/DOCUMENT/TUTORIALATS/tutorialatxt.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from chap_callbyref.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="callbyref">
#title("Call-by-Reference")

#para("\

The feature of call-by-reference in ATS is similar to the corresponding one
in C++. What is special in ATS is the way in which this feature is handled
by the type system.  In general, if #code("f") is given a type of the following
form for some viewtypes #code("VT1") and #code("VT2"):

#atscode("\
(..., &VT1 >> VT2, ...) -> ...
")

then a function call #code("f(..., lval, ...)") on some left-value
#code("lval") of the viewtype #code("VT1") is to change the viewtype of
#code("lval") into #code("VT2") upon its return.  In the case where
#code("VT1") and #code("VT2") are the same, #code("&amp;VT1 >> VT2") may
simply be written as #code("&amp;VT1").

")#comment("para")

#para("\

As an example, an implementation of the factorial function is given as
follows that makes use of call-by-reference:

#atscode_extract("\
fun fact (x: int): int = let
  fun loop {l:addr} (x: int, res: &int): void =
    if x > 0 then (res := res * x; loop (x-1, res)) else ()
  var res: int = 1 // [res] is a variable!
in
  loop (x, res); res
end // end of [fact]
")

Note that if the line for introducing the variable #code("res") in the
above implementation is replaced with the following one:

#atscode("\
  val res: int = 1 // [res] is no longer a variable but a value!
")

then a type error is to be reported as #code("res") is no longer a left-value
when it is passed as an argument to #code("loop").

")#comment("para")

#para("\
In functional programming, optional types are often used for
error-handling. For instance, the following function #code("divopt")
returns a value of the type #code("Option(int)") that either contains
the result of the division or indicates a case of division-by-zero:

#atscode_extract("\
fun divopt
  (x: int, y: int): Option (int) =
  if y != 0 then Some (x/y) else None ()
// end of [divopt]
")

Given that a value of the form #code("Some(v)") is heap-allocated, the
memory for storing it can only be reclaimed by garbage collection (GC).
In other words, the memory is leaked if GC is not available. To address
the issue of error-handing in the absence of GC, we can employ call-by-reference
as is shown below:

#atscode_extract("\
fun diverr (
  x: int, y: int, err: &int
) : int =
  if y != 0 then x/y else (err := err+1; 0(*meaningless*))
// end of [diverr]
")

We can tell whether division-by-zero has occurred by comparing the values
of #code("err") before and after a call to #code("diverr"). This style of
error-handling is commonly seen in code written in languages like C.

")#comment("para")

</chapter><!--"callbyref"-->

#comment(" ****** ****** ")

#comment(" end of [chap_callbyref.atxt] ")

%{
implement main () = {
//
  val filr =
    $STDIO.fopen_ref_exn ("CODE/chap_callbyref.dats", file_mode_w)
  val () = fprint_theCodeLst (filr)
  val () = $STDIO.fclose_exn (filr)
//
  val () = fprint_filsub (stdout_ref, "chap_callbyref_atxt.txt")
//
}
%}
