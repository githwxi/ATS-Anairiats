%{
//
dynload "libatsdoc/dynloadall.dats"
#include "utils/atsdoc/DOCUMENT/TUTORIALATS/tutorialatxt.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from chap_polytemp.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="polytemp">
#title("Parametric Polymorphism")

#para("\

Parametric polymorphism (or polymorphism for short) offers a flexible and
effective approach to supporting code reuse. For instance, given a pair
(v1, v2) where v1 and v2 are a boolean a character, respectively, the
function #code("swap_bool_char") defined below returns a pair (v2, v1):

#atscode_extract("\
fun swap_bool_char (xy: (bool, char)): (char, bool) = (xy.1, xy.0)
")

Suppose that integer values need to be swapped as well. This leads to the
implementation of the following function #code("swap_int_int"):

#atscode_extract("\
fun swap_int_int (xy: (int, int)): (int, int) = (xy.1, xy.0)
")

The code duplication between #code("swap_bool_char") and
#code("swap_int_int") is obvious, and it can be easily avoided by implementing a
function template as follows:

#atscode_extract("\
fun{a,b:t@ype} swap (xy: (a, b)): (b, a) = (xy.1, xy.0)
")

Now the functions #code("swap_bool_char") and #code("swap_int_int") can
simply be replaced with #code("swap&lt;bool,char&gt;") and
#code("swap&lt;int,int&gt;"), respectively. The function template
#code("swap") cannot be compiled into binary object code directly as the
sizes of type variables #code("a") and #code("b") are unknown: The special
sort #code("t@ype") is for classifying types whose sizes are unspecified. If
#code("swap&lt;T1,T2&gt;") is used for some types T1 and T2 of known sizes,
then an instantiation of #code("swap") is created where type variables
#code("a") and #code("b") are replaced with T1 and T2, respectively, and
the instantiation is compiled into binary object code. For those know the
feature of templates in C++, this should sound rather familiar.

")#comment("para")

#para("\

In contrast to #code("swap"), #code("swap_type_type") is defined below as a
polymorphic function (rather than a function template):

#atscode_extract("\
fun swap_type_type {a,b:type} (xy: (a, b)): (b, a) = (xy.1, xy.0)
")

This function can be compiled into binary object code as the sizes of type
variables #code("a") and #code("b") are known: The special sort
#code("type") is for classifying types of size equal to exactly one word,
that is, the size of a pointer. For example, the size of a string is one
word, and the size of any declared datatype is also one word.  Given
strings #code("str1") and #code("str2"), an application of
#code("swap_type_type") to #code("str1") and #code("str2") can be written
as follows:

#atscode("\
swap_type_type {string,string} (str1, str2)
")

where the expression #code("{string,string}") is often referred to as a
static argument. As in this case, most static arguments do not have to be
supplied explicitly since they can be automatically inferred.  However,
such static arguments, if given, can often greatly enhance the quality and
precision of the error messages reported in case of typechecking failure.

")#comment("para")


</chapter><!--"polytemp"-->

#comment(" ****** ****** ")

#comment(" end of [chap_polytemp.atxt] ")

%{
implement main () = {
//
  val filr =
    $STDIO.fopen_ref_exn ("CODE/chap_polytemp.dats", file_mode_w)
  val () = fprint_theCodeLst (filr)
  val () = $STDIO.fclose_exn (filr)
//
  val () = fprint_filsub (stdout_ref, "chap_polytemp_atxt.txt")
//
}
%}
