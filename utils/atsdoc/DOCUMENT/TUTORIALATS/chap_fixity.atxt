%{
//
dynload "libatsdoc/dynloadall.dats"
#include "utils/atsdoc/DOCUMENT/TUTORIALATS/tutorialatxt.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from chap_fixity.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="fixity">
#title("Fixity Declarations")

#para("\

Given a function #emph("f"), the standard syntax for applying #emph("f") to
an argument #emph("v") is #emph("f(v)"); for two arguments #emph("v1") and
#emph("v2"), the syntax is #emph("f(v1, v2)"). However, it is allowed in
ATS to use infix notation for a binary function application, and prefix/postifix
notation for a unary function application.

")

#para("\

Each identifier in ATS can be assigned one of the following fixities:
#emph("prefix"), #emph("infix") and #emph("postfix").  The fixity
declarations for many commonly used identifiers can be found in
#myatsdoclink("prelude/fixity.ats", "prelude/fixity.ats").  Often, the
name #emph("operator") is used to refer to an identifier that is assigned a
fixity. For instance, the following syntax declares that #code("+") and
#code("-") are infix operators of a precedence value equal to 50:

#atscode("\
infixl 50 + -
")

After this declaration, we can write an expression like #code("1 + 2 - 3"),
which is parsed into #code("-(+(1, 2), 3)") in terms of the standard syntax
for function application.
")#comment("para")

#para("\

The keyword #code("infixl") indicates that the declared infix operators are
left-associative. For right-associative and non-associative infix
operators, please use the keywords #code("infixr") and #code("infix"),
respectively. If the precedence value is omitted in a fixity declaration,
it is assumed to be equal to 0.

")

#para("\

We can also use the following syntax to declare that
#code("iadd"), #code("fadd"), #code("padd") and #code("uadd") are left-associative
infix operators with a precedence value equal to that of the operator #code("+"):

#atscode("\
infixl (+) iadd fadd padd uadd
")

This is useful as it is difficult in practice to remember the precedence
values of (a large collection of) declared operators. Sometimes, we may
need to specify that the precedence value of one operator in relation to
that of another one. For instance, the following syntax declares that
#code("opr2") is a left-associative infix operator and its precedence value
is that of #code("opr1") plus 10:

#atscode("\
infixl (opr1 + 10) opr2
")

If the plus sign (+) is changed to the minus sign (-), then the precedence
value of #code("opr2") is that of #code("opr1") minus 10.
")#comment("para")

#para("\

We can also turn an identifier #code("opr") into a non-associative infix
operator (of precedence value 0) by putting the backslash symbol
(#code("\\\\")) in front of it. For instance, the expression #code("exp1
\\\\opr exp2") stands for #code("opr (exp1, exp2)"), where #code("exp1")
and #code("exp2") refer to some expressions, either static or dynamic.

")

#para("\

The syntax for declaring (unary) prefix and postfix operators are
similar. For instance, the following syntax declares that #code("~") and
#code("?") are prefix and postfix operators of precedence values 61 and 69,
respectively:

#atscode("\
prefix 61 ~
postfix 69 ?
")

As an example, a postfix operator is involved in the following 3-line
program:

#atscode("\
postfix (imul + 10) !!
extern fun !! (x: int): int
implement !! (x) = if x >= 2 then x * (x - 2)!! else 1
")
")#comment("para")

#para("\

For a given occurrence of an operator, we can deprive it of its assigned
fixity status by simply putting the keyword #code("op") in front of it. For
instance #code("1 + 2 - 3") can be writen as #code("op- (op+ (1, 2), 3)").
It is also possible to (permanently) deprive an operator of its assigned
fixity status.  For instance, the following syntax does so to the operators
#code("iadd"), #code("fadd"), #code("padd") and #code("uadd"):

#atscode("\
nonfix iadd fadd padd uadd
")
")#comment("para")

#para("\

Lastly, please note that each fixity declaration is only effective within
its own legal scope.

")

</chapter><!--"fixity"-->

#comment(" ****** ****** ")

#comment(" end of [chap_fixity.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "chap_fixity_atxt.txt")
%}
