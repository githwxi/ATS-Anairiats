%{
//
dynload "libatsdoc/dynloadall.dats"
#include "utils/atsdoc/DOCUMENT/TUTORIALATS/tutorialatxt.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from chap_lazyeval.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="lazyeval">
#title("Lazy Evaluation")

#para("\

Though ATS is a language based on eager call-by-value evaluation, it also
allows the programmer to perform lazy call-by-need evaluation.  In ATS,
there is a special language construct #code("$delay") that can be used to
delay or suspend the evaluation of an expression (by forming a thunk) and a
special function #code("lazy_force") that can be called to resume a
suspended evaluation (represented by a thunk).

")

#para("\

There is a special type constructor #code("lazy") of the sort
#code("(t@ype) =&gt; type") in ATS, which forms a (boxed) type when applied
to a type.  On one hand, given an expression exp of type T,
#code("$delay")(exp) forms a value of the type #code("lazy")(T) that
represents the suspended evaluation of exp.  On the other hand, given a
value v of the type #code("lazy")(T) for some type T,
#code("lazy_force")(v) resumes the suspended evaluation represented by v
and returns a result of type T. The interface for the function template
#code("lazy_force") is given as follows:

#atscode("\
fun{a:t@ype} lazy_force (x: lazy a):<!laz> a
")

Note that the symbol #code("!laz") indicates a form of effect associated
with lazy-evaluation.  For cleaner syntax, the special prefix operator
#code("!") in ATS is overloaded with #code("lazy_force").

")

#para("\

In #myatsdoclink("prelude/SATS/lazy.sats", "prelude/SATS/lazy.sats"), the
following datatype #code("stream_con") and #code("stream") are declared
mutually recursively for representing (lazy) streams:

#atscode("\
datatype stream_con (a:t@ype+) =
  | stream_nil (a) of () | stream_cons (a) of (a, stream a)
where stream (a:t@ype) = lazy (stream_con a)
")

Also, a number of common functions on streams are declared in
#myatsdoclink("prelude/SATS/lazy.sats", "prelude/SATS/lazy.sats") and
implemented in #myatsdoclink("prelude/DATS/lazy.dats", "prelude/DATS/lazy.dats").

")#comment("para")

#para("

The following code gives a standard implementation of the sieve of
Eratosthenes. We first construct a stream of all the integers starting from
2 that are ordered ascendingly; we keep the first element of the stream and
remove all of its multiples; we repeat this process on the rest of the
stream recursively. The final stream then consists of all the prime numbers
ordered ascendingly.

#atscode_extract("\
\#define nil stream_nil
\#define cons stream_cons
\#define :: stream_cons

typedef N2 = [n:int | n >= 2] int n
val N2s: stream N2 = from 2 where {
  fun from (n: N2):<!laz> stream N2 = $delay (n :: from (n+1))
}

fun sieve
  (ns: stream N2):<!laz> stream N2 = let
  // [val-] means no warning message from the compiler
  val- n :: ns = !ns
in
  $delay (n :: sieve (stream_filter_cloref<N2> (ns, lam x => x nmod n > 0)))
end // end of [sieve]

val primes: stream N2 = sieve N2s

//
// Finding the nth prime where counting starts from 0
//
fn nprime {n: nat} (n: int n): N2 = stream_nth (primes, n)
")

The function template #code("stream_filter_cloref") is of the following
interface:

#atscode("\
fun{a:t@ype}
stream_filter_cloref
  (xs: stream a, p: a -<cloref,!laz> bool):<!laz> stream a
")

It is called to construct a stream consisting of all the elements in a
given stream that satisfy a given predicate.

")#comment("para")

#para("\

We give another example of lazy-evaluation as follows, which
demonstrates an interesting approach to computing Fibonacci numbers:

#atscode_extract("\
val one = int64_of_int 1

val // the following values are defined mutually recursively
rec fibs_1: stream int64 = $delay (one :: fibs_2) // fib1, fib2, ...
and fibs_2: stream int64 = $delay (one :: fibs_3) // fib2, fib3, ...
and fibs_3: stream int64 = ( // fib3, fib4, ...
  stream_map2_fun<int64,int64><int64> (fibs_1, fibs_2, lam (x, y) => x + y)
)
// find the nth Fibonacci number
fn nfib {n:pos} (n: int n): int64 = stream_nth (fibs_1, n-1)
")

The function template #code("stream_map2_fun") is assigned the following
interface:

#atscode("\
fun{a1,a2:t@ype}{b:t@ype}
stream_map2_fun
  (xs1: stream a1, xs2: stream a2, f: (a1, a2) -<!laz> b):<!laz> stream b
")

Given two streams xs1 and xs2 and a binary function f,
#code("stream_map2_fun") forms a stream such that the #emph("n")th element
in it, if it exists, equals f(x1, x2), where x1 and x2 are the #emph("n")th
elements in xs1 and xs2, respectively.

")#comment("para")

</chapter><!--"lazyeval"-->

#comment(" ****** ****** ")

#comment(" end of [chap_lazyeval.atxt] ")

%{
implement main () = {
//
  val filr =
    $STDIO.fopen_ref_exn ("CODE/chap_lazyeval.dats", file_mode_w)
  val () = fprint_theCodeLst (filr)
  val () = $STDIO.fclose_exn (filr)
//
  val () = fprint_filsub (stdout_ref, "chap_lazyeval_atxt.txt")
//
}
%}
