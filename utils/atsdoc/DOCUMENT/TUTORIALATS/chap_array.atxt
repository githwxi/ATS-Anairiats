%{
//
dynload "libatsdoc/dynloadall.dats"
#include "utils/atsdoc/DOCUMENT/TUTORIALATS/tutorialatxt.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from chap_array.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="array">
#title("Persistent Arrays")

#para("\

A persistent array of size n is just n heap-allocated cells (or references)
in a row.  It is persistent in the sense that the memory allocated for the
array cannot be freed manually. Instead, it can only be reclaimed through
garbage collection (GC).

")

#para("\

Given a viewtype VT, the type for arrays containing n values of viewtype VT
is #code("array")(VT, n).  Note that arrays in ATS are the same as those in
C: There is no size information attached them. The interfaces for various
functions on arrays can be found in
#myatsdoclink("prelude/SATS/array.sats", "prelude/SATS/array.sats").

")#comment("para")

#para("\
There are various functions for array creation. For instance, the following
two are commonly used:

#atscode("\
fun{a:t@ype}
array_make_elt
  {n:nat} (asz: size_t n, elt: a):<> array (a, n)
// end of [array_make_elt]

fun{a:t@ype}
array_make_lst {n:nat}
  (asz: size_t n, xs: list (a, n)):<> array (a, n)
// end of [array_make_lst]
")

Applied to a size and an element, #code("array_make_elt") returns an array
of the given size in which each cell is initialized with the given element.
Applied to a size and a list of elements, #code("array_make_lst") returns
an array of the given size in which each cell is initialized with the
corresponding element in the given list.

")

#para("\
For reading from and writing to an array, the
function templates #code("array_get_elt") and #code("array_set_elt") can be
used, respectively,
which are assigned the following interfaces:

#atscode('\
fun{a:t@ype}
array_get_elt_at {n:int}
  {i:nat | i < n} (A: array (a, n), i: size_t i):<!ref> a

fun{a:t@ype}
array_set_elt_at {n:int}
  {i:nat | i < n} (A: array (a, n), i: size_t i, x: a):<!ref> void
')

Given an array #code("A"), an index #code("i") and a value #code("v"),
#code("array_get_elt_al(A, i)") and #code("array_set_elt_at(A, i, v)") can
be written as #code("A[i]") and #code("A[i] := v"), respectively.

")

#para("

As an example, the following function template reverses the content
of a given array:

#atscode_extract('\
fun{a:t@ype}
array_reverse {n:nat} (
  A: array (a, n), n: size_t (n)
) : void = let
  fun loop {i: nat | i <= n} .<n-i>.
    (A: array (a, n), n: size_t n, i: size_t i): void =
    if i < n/2 then let
      val tmp = A[i]
    in
      A[i] := A[n-1-i]; A[n-1-i] := tmp; loop (A, n, i+1)
    end else () // end of [if]
  // end of [loop]
in
  loop (A, n, 0)
end // end of [array_reverse]
')

")

#para("\

If the test #code("i < n/2") is changed to #code("i <= n/2"), a type-error
is to be reported. Why? The reason is that #code("A[n-1-i]") becomes
out-of-bounds array subscripting in the case where #code("n") and
#code("i") both equal zero. Given that it is very unlikely to encounter a
case where an array of size 0 is involved, a bug like this, if not detected
early, can be buried so scarily deep!\

")

#para("\

The careful reader may have already noticed that the sort #code("t@ype") is
assigned to the template parameter #code("a"). In other words, the above
implementation of #code("array_reverse") cannot handle a case where the
values stored in a array are of a linear type. The reason for choosing the
sort #code("t@ype") is that both #code("array_get_elt_at") and
#code("array_set_elt_at") can only be applied an array containing values of
a nonlinear type. In the following implementation, the template parameter
is given the sort #code("viewt@ype") so that an array containing values of
a linear type can be handled:

")

#atscode_extract('\
fun{a:viewt@ype}
array_reverse {n:nat} (
  A: array (a, n), n: size_t (n)
) : void = let
  fun loop {i: nat | i <= n} .<n-i>.
    (A: array (a, n), n: size_t n, i: size_t i): void =
    if i < n/2 then let
      val () = array_exch (A, i, n-1-i) in loop (A, n, i+1)
    end else () // end of [if]
  // end of [loop]
in
  loop (A, n, 0)
end // end of [array_reverse]
')

#para("
The interface for the function template #code("array_exch") is given below:

#atscode('\
fun{a:viewt@ype}
array_exch {n:nat}
  (A: array (a, n), i: sizeLt n, j: sizeLt n):<!ref> void
// end of [array_exch]
')

Note that #code("array_exch") can not be implemented in terms of
#code("array_get_elt_at") and #code("array_set_elt_at") (unless some form
of type-unsafe coding is empolyed). The curious reader can find its
type-safe implementation in #myatsdoclink("prelude/DATS/array.dats",
"prelude/DATS/array.dats"), which is based on a corresponding operation for
linear arrays.

")

</chapter><!--"array"-->

#comment(" ****** ****** ")

#comment(" end of [chap_array.atxt] ")

%{
implement main () = {
//
  val filr =
    $STDIO.fopen_ref_exn ("CODE/chap_array.dats", file_mode_w)
  val () = fprint_theCodeLst (filr)
  val () = $STDIO.fclose_exn (filr)
//
  val () = fprint_filsub (stdout_ref, "chap_array_atxt.txt")
//
} // end of [main]
%}
