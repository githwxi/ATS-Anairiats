%{
//
dynload "libatsdoc/dynloadall.dats"
#include "utils/atsdoc/DOCUMENT/TUTORIALATS/tutorialatxt.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from chap_tailrec.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="tailrec">
#title("Tail-Recursive Call Optimization")

#para("\

Tail-recursion is of crucial importance in functional programming as loops
in imperative programming are often implemented as tail-recursive functions.

")

#para('\

Suppose that a function #emph("foo") calls another function #emph("bar"),
that is, there is a call to #emph("bar") appearing in the body of
#emph("foo"), where #emph("foo") and #emph("bar") may actually be the same
function. If the return value of the call to #emph("bar") also happens to be
the return value of #emph("foo"), then this call is often referred to as a
#emph("tail-call"). If #emph("foo") and #emph("bar") are the same, then
this call is a (recursive) self tail-call. For instanace, there are two
recursive calls in the body of the following defined function #code("f91"):

')

#atscode_extract("\
fun f91 (n: int): int = if n > 100 then n - 10 else f91 (f91 (n+11))
")

#para('\

where the outer call to #code("f91") is a tail-call while the inner one is
not. If each self call in the body of a function is a tail-call, then this
function is tail-recursive.

')#comment("para")

#para("\

It is arguably that the single most important optimization performed by the
ATS compiler is the translation of every self tail-call into a direct
(local) jump. This optimization effectively turns every tail-recursive
function into the equivalent of a loop, guaranteeing that a fixed amount of
stack space is adequate for executing each call to the function.

")#comment("para")


#para("\

Let us now see some examples that can help further illustrate the notion of
tail-recursive call optimization. The following recursive function
#code("sum1") sums up all the natural numbers less than or equal to a given
integer parameter #code("n"):

")

#atscode_extract("\
fun sum1 (n: int): int = if n > 0 then n + sum1 (n-1) else 0
")

#para("\

Clearly, #code("sum1") is not tail-recursive as the only self call in its
body is not a tail-call.  The counterpart of #code("sum1") in C can
essentially be given as follows:

#atscode("\
int sum1 (int n) {
  return (n > 0) ? n + sum1 (n-1) : 1 ;
} // end of [sum1]
")

When applied to an integer #code("n"), the following defined function
#code("sum2") also sums up all the natural numbers less than or equal to
#code("n"):

#atscode_extract("\
fn sum2 (n: int): int = let
  fun loop (n: int, res: int): int =
    if n > 0 then loop (n-1, res + n) else res
  // end of [loop]
in
  loop (n, 0)
end // end of [sum2]
")

The inner function #code("loop") in the definition of #code("sum2") is
tail-recursive.  The stack space consumed by #code("loop") is constant,
that is, it is independent of the values of the arguments of #code("loop").
Essentially, the ATS compiler translates the definition of #code("sum2")
into the following C code:

#atscode("\
int sum2_loop (int n, int res) {
  loop:
  if (n > 0) {
    res = res + n ; n = n - 1; goto loop; 
  } else {
    // do nothing
  }
  return res ;
}

int sum2 (int n) { return sum2_loop (n, 0) ; }
")

")#comment("para")

#para("\

Translating #code("sum1") into #code("sum2") is a fairly straightforward
process. However, it can be highly involved, sometimes, to turn a
non-tail-recursive implementation into an equivalent one that is
tail-recursive.

")

</chapter><!--"tailrec"-->

#comment(" ****** ****** ")

#comment(" end of [chap_tailrec.atxt] ")

%{
implement main () = {
//
  val filr =
    $STDIO.fopen_ref_exn ("CODE/chap_tailrec.dats", file_mode_w)
  val () = fprint_theCodeLst (filr)
  val () = $STDIO.fclose_exn (filr)
//
  val () = fprint_filsub (stdout_ref, "chap_tailrec_atxt.txt")
//
}
%}
