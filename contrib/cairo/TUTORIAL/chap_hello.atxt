%{
//
dynload "libatsdoc/dynloadall.dats"
#include "utils/atsdoc/DOCUMENT/TUTORIALATS/tutorialatxt.dats"
//
#include "tutorialatxt.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from chap_hello.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="hello_example">
#title("A Simple Example: Hello, world!")

#para("\
The first program we present in this tutorial is given as follows:
")

#atscodefil("CODE/tutprog_hw.dats.extract")

#para("\
The functions in the cairo package are declared in the following file:
#ulink1(
"#ATSLANGSVNROOTget()/contrib/cairo/SATS/cairo.sats", "contrib/cairo/SATS/cairo.sats"
)
")#comment("para")

#para("\
Note that in this tutorial, a file name, if relative, is always relative to
the ATS home directory (stored in the environment variable ATSHOME) unless
it is specified otherwise.
")

#para('\

Suppose that the presented program is stored in a file named
#mycodelink("tutprog_hw.dats", "tutprog_hw.dats") the following
command can be issued to compile the program to generate an executable
#filename("tutprog_hw"):

<informalexample><programlisting>
#command("atscc") -o tutprog_hw tutprog_hw.dats `pkg-config cairo --cflags --libs`
</programlisting></informalexample>

')

#para("\

By executing #filename("tutprog_hw"), we generate a PNG image file
#myimagelink("tutprog_hw.png", "tutprog_hw.png"), which is included as
follows:\

")

#para('\
<inlinemediaobject>
<imageobject>
<imagedata fileref="#MYIMAGEROOTget()/tutprog_hw.png" format="PNG"/>
</imageobject>
</inlinemediaobject>
')

#para("\

One can also use tools such #command("eog") and #command("gthumb") to view
PNG files.

")

#para("\

We now give a brief explanation on the program in
#mycodelink("tutprog_hw.dats", "tutprog_hw.dats").  We first create a
cairo surface for drawing:\

")

#atscode('\
  val surface = // create a surface for drawing
    cairo_image_surface_create (CAIRO_FORMAT_ARGB32, 250, 80)
')

#para("\
We then use the surface to create a cairo context:
")

#atscode('\
  val cr = cairo_create (surface)
')

#para("\
We choose a font face and set the font size to 32.0:
")

#atscode('\
  val () = cairo_select_font_face
    (cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD)
  val () = cairo_set_font_size (cr, 32.0)
')

#para('\
Imagine that we are holding a pen. We set the color of the pen
to blue:
')

#atscode('\
  // the call [cairo_set_source_rgb] sets the color to blue
  val () = cairo_set_source_rgb (cr, 0.0(*r*), 0.0(*g*), 1.0(*b*))
')

#para("
We now move the pen to the postion (10.0, 50.0):
")

#atscode('\
  val () = cairo_move_to (cr, 10.0, 50.0)
')

#para('\
and use the pen to write down the text "Hello, world!":
')

#atscode('\
  val () = cairo_show_text (cr, "Hello, world!")
')

#para("\
At this point, we have finished drawing. We store the image drawn on the
surface into a PNG file:
")

#atscode('\
  val status = cairo_surface_write_to_png (surface, "tutprog_hw.png")
')

#para("
We now enter the cleanup phase, closing both the surface and the context:
")

#atscode('\
  val () = cairo_surface_destroy (surface) // a type error if omitted
  val () = cairo_destroy (cr) // a type error if omitted
')

#para("\
In case of a failure, we report it:
")

#atscode("\
  // in case of a failure ...
  val () = assert_errmsg (status = CAIRO_STATUS_SUCCESS, \#LOCATION)
")

#para("\

On the surface, it seems that using cairo functions in ATS is nearly
identical to using them in C (modulo syntatical difference). However, what
happens at the level of typechecking in ATS is far more sophisticated than
in C. In particular, linear types are assigned to cairo objects (e.g.,
contexts, surfaces, patterns, font faces) in ATS to allow them to be
tracked statically, that is, at compile-time, preventing potential memory
mismanagement. For instance, if the following line:

")

#atscode("\
  val () = cairo_surface_destroy (surface) // a type error if omitted
")

#para("\

is removed from the program in
#mycodelink("tutprog_hw.dats", "tutprog_hw.dats"),
then a type-error message is issued at compile-time to indicate that the
resource #code("surface") is not properly freed.  A message as such can be
of great value in practice for correcting potential memory leaks that may
otherwise readily go unnoticed.  ATS is a programming language that
distinguishes itself in its practical and effective support for precise
resource management.

")

</chapter>#comment("chapter/hello_example")

#comment(" ****** ****** ")

#comment(" end of [chap_hello.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "chap_hello_atxt.txt")
%}
